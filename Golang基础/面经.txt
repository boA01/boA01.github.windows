垃圾回收算法：
    引用计数：引用+1，销毁-1，0回收
        优点：回收快
        缺点：不好处理循环引用
    标记清除：遍历所有引用对象并标记，未标记的则清除
        优点：解决引用计数的缺点
        缺点：需要STW，暂停程序
        优化：三色并发标记法：不用一次性完成
                三种状态，由 白->灰->黑，回收白色
                写屏障，本轮中指针传递时直接标记指针
        注意：GC过程中，新分配的内存立即标记，不属于写屏障技术
    分代回收：按生命周期划分不同代空间，不同代的回收算法和频率不同
        优点：回收性能好
        缺点：算法复杂

辅助GC：防止内存分配过快，GC过程中，需要分配内存的goroutine分担GC部分工作
触发时机：内存分配时都检测只用量是否达到阈值，达到就立即启动。
         增长率大于1时启动GC；GOGC监控增长率，默认100
         2min必触发GC
         runtime.GC() 手动触发

// 分治(nlog2 n; n^2; nlog2 n; log2 n)
func QuickSort(s []int) []int {
	if len(s) > 1 {
		var larr, rarr, mid []int
		mid = append(mid, s[0])

		for _, v := range s[1:] {
			if v > splitdata {
				rarr = append(rarr, v)
			} else if v < splitdata {
				larr = append(larr, v)
			} else {
				mid = append(mid, v)
			}
		}
		return append(append(QuickSort(larr), mid...), QuickSort(rarr)...)
	} else {
		return s
	}
}

// 当前项向前找到合适位置（n; n^2; n^2; 1）
func insertSort(s []int) {
    l := len(s)
    var temp int
    var j int

    for i:=1; i<l; i++ { // 第二项开始
        temp = s[i]
        for j = i-1; j >= 0 && temp < s[j]; j-- {
            s[j+1] = s[j]
        }
        s[j+1] = temp
    }
    fmt.Println(s)
}

// 前一项与后一项比较，确定末尾（n; n^2; n^2; 1）
func bubbleSort(s []int) {
    for i := len(s)-1; i > 0; i-- {
        flag := true
        for j := 0; j < i; j++ {
            if s[j] > s[j+1] {
                s[j], s[j+1] = s[j+1], s[j]
                flag = false
            }
        }
        if flag {
            break
        }
    }
    fmt.Println(s)
}

// 当前项与其余项比较，确定当前位（n^2; n^2; n^2; 1）
func selectSort(s []int) {
    for i := len(s)-1; i > 0; i-- {
        for j := 0; j < i; j++ {
            if s[i] < s[j] {
                s[j], s[i] = s[i], s[j]
            }
        }
    }
    fmt.Println(s)
}

// 动态规划（dp数组存放标记）
func maxStr(s []int) {
    l := len(s)
    var dp = make([]int, l)
    var index int
    dp[0] = s[0]
    max := dp[0]

    for i := 1; i < l; i++ {
        m := s[i] + dp[i-1]
        if m > s[i] {
            dp[i] = m
        } else { // 更新（dp和起始位置）
            dp[i] = s[i]
            index = i
        }
        if dp[i] > max {
            max = dp[i]
        }
    }
    fmt.Println(dp, max, index)
}

// 翻转链表
func reverseList(head *ListNode) *ListNode {
    cur := head
    var pre *ListNode = nil // 前驱结点
    for cur != nil {
        cur.next, pre, cur = pre, cur, cur.next
    }
    return pre
}

// 翻转字符串
func reverseStr(str string) string {
    s := []rune(str)
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
    return string(s)
}

reflect.StringHeader{}
reflect.SliceHeader{}
unsafe.Pointer(&x)

slice扩容？
<1024  cap() *= 2
>=1024 cap() *= 1.25（注意内存对齐，查看growslice()）

struct比较？
相同类型
    不存在slice，map，func可以比较
    否则reflect.DeepEqual()比较
不同类型（强类型）
    强制类型转换后比较

判断接口是否为nil？
类型，数据
func IsNil(i interface{}) {
    vi := reflect.ValueOf(i)
    if vi.Kind() == reflect.Ptr {
        return vi.IsNil()
    }
    return false
}

go init 的执行顺序？
一个文件里，从上到下
一个包里面，官方没明确说明，文件名大小
不同包，按导入的依赖关系

CSP并发模型
不要以共享内存通信，要用通信来共享内存

GMP模型？
M：系统线程（有固定大小的栈）
G：协程（栈动态扩缩；都需要一个P）
P：上下文（运行在M上的调度器，默认大小cpu核数，原生代码不需要）

go协程的4种状态
Runnable
Running
Syscall
Waiting

goroutine与coroutine
py协程：1:N，采用EVENTLOOP模型；需要await主动交出控制权，
        虽然可以实现异步io，但是不能多效利用多核（GIL）
go协程：M:N，采用CSP模型；可以多线程分配到不同核心上
相同点：都引人消息调度系统模型，通过消息机制交流，

context有什么作用？
上下文，上层向下层传递内容（常用于 关闭后台协程）；阻塞

select作用？
阻塞；随机

阻塞？
<-make(chan int)
for{}
select{}
sync.Mutex（不可赋值, 不可重复上锁）
wg = sync.WaitGroup{}
wg.Add(num)
wg.Done()
wg.Wait()
runtime.Gosched() // 调度语句

一颗CPU，两个协程，其中一个协程在死循环，会发生什么？
1.14前跑死；以后不会，

go如何关闭协程？
上下文，cancel()调用 <-ctx.Done() （控制流）
close(ch)，广播

go协程池？

go的调度？
1.14后，协作式抢占调度，用户态的协程调度器

web应用程序使用http协议传输，http是无状态协议。需要会话机制来记录
cookie与session
客户端记录确定用户信息，携带通行证建立连接，具有不可跨域名性；不安全，但可以加密；记住密码
服务端记录用户确认信息，sessionID在客户端；容易失效，

Redis淘汰策略？
默认策略，不淘汰任何key
LRU，LFU
随机淘汰，过期，TTL短的

Redis高可用？
主从复制：
哨兵模式：无法较好的进行水平扩展
集群模式：