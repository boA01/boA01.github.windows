垃圾回收算法：
    引用计数：引用+1，销毁-1，0回收
        优点：回收快
        缺点：不好处理循环引用
    标记清除：遍历所有引用对象并标记，未标记的则清除
        优点：解决引用计数的缺点
        缺点：需要STW，暂停程序
        优化：三色并发标记法：不用一次性完成
                三种状态，由 白->灰->黑，回收白色
                写屏障，本轮中指针传递时直接标记指针
        注意：GC过程中，新分配的内存立即标记，不属于写屏障技术
    分代回收：按生命周期划分不同代空间，不同代的回收算法和频率不同
        优点：回收性能好
        缺点：算法复杂

辅助GC：防止内存分配过快，GC过程中，需要分配内存的goroutine分担GC部分工作
触发时机：内存分配时都检测只用量是否达到阈值，达到就立即启动。
         增长率大于1时启动GC；GOGC监控增长率，默认100%
         2min必触发GC
         runtime.GC() 手动触发

// 分治(nlog2 n; n^2; nlog2 n; log2 n)
func QuickSort(s []int) []int {
	if len(s) > 1 {
		var larr, rarr, mid []int
        splitdata := s[0]
		mid = append(mid, splitdata)

		for _, v := range s[1:] {
			if v > splitdata {
				rarr = append(rarr, v)
			} else if v < splitdata {
				larr = append(larr, v)
			} else {
				mid = append(mid, v)
			}
		}
		return append(append(QuickSort(larr), mid...), QuickSort(rarr)...)
	} else {
		return s
	}
}

// 当前项向前找到合适位置（n; n^2; n^2; 1）
func insertSort(s []int) {
    l := len(s)
    var temp int
    var j int

    for i:=1; i<l; i++ { // 第二项开始
        temp = s[i]
        for j = i-1; j >= 0 && temp < s[j]; j-- {
            s[j+1] = s[j]
        }
        s[j+1] = temp
    }
    fmt.Println(s)
}

// 前一项与后一项比较，确定末尾（n; n^2; n^2; 1）
func bubbleSort(s []int) {
    for i := len(s)-1; i > 0; i-- {
        flag := true
        for j := 0; j < i; j++ {
            if s[j] > s[j+1] {
                s[j], s[j+1] = s[j+1], s[j]
                flag = false
            }
        }
        if flag {
            break
        }
    }
    fmt.Println(s)
}

// 当前项与其余项比较，确定当前位（n^2; n^2; n^2; 1）
func selectSort(s []int) {
    for i := len(s)-1; i > 0; i-- {
        for j := 0; j < i; j++ {
            if s[i] < s[j] {
                s[j], s[i] = s[i], s[j]
            }
        }
    }
    fmt.Println(s)
}

// 动态规划（dp数组存放标记）
func maxStr(s []int) {
    l := len(s)
    var dp = make([]int, l)
    var index int
    dp[0] = s[0]
    max := dp[0]

    for i := 1; i < l; i++ {
        m := s[i] + dp[i-1]
        if m > s[i] {
            dp[i] = m
        } else { // 更新（dp和起始位置）
            dp[i] = s[i]
            index = i
        }
        if dp[i] > max {
            max = dp[i]
        }
    }
    fmt.Println(dp, max, index)
}

// 翻转链表
func reverseList(head *ListNode) *ListNode {
    cur := head
    var pre *ListNode = nil // 前驱结点
    for cur != nil {
        cur.next, pre, cur = pre, cur, cur.next
    }
    return pre
}

// 翻转字符串
func reverseStr(str string) string {
    s := []rune(str)
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
    return string(s)
}

reflect.StringHeader{}
reflect.SliceHeader{}
unsafe.Pointer(&x)

slice扩容？
<1024  cap() *= 2
>=1024 cap() *= 1.25（注意内存对齐，查看growslice()）

struct比较？（==，!=）
相同类型
    不存在不可比较类型，可以比较
    匿名字段留意
    否则reflect.DeepEqual()比较
不同类型（强类型）
    强制类型转换后比较
结构体不能排序（<, >, <=, >=）
不可比较类型：slice，map，func
不可序列化类型：chanle，func，complex

判断接口是否为nil？
类型，数据
func IsNil(i interface{}) {
    vi := reflect.ValueOf(i)
    if vi.Kind() == reflect.Ptr {
        return vi.IsNil()
    }
    return false
}

go init 的执行顺序？
一个文件里，从上到下
一个包里面，官方没明确说明，文件名大小
不同包，按导入的依赖关系

CSP并发模型
不以共享内存通信，要用通信来共享内存

GMP模型？
M：系统线程（有固定大小的栈）
G：协程（栈动态扩缩；都需要一个P）
P：上下文（运行在M上的调度器，默认大小cpu核数，原生代码不需要）

go协程的4种状态
Runnable
Running
Syscall
Waiting

goroutine与coroutine
py协程：1:N，采用EVENTLOOP模型；需要await主动交出控制权，
        虽然可以实现异步io，但是不能多效利用多核（GIL）
go协程：M:N，采用CSP模型；可以多线程分配到不同核心上
相同点：都引人消息调度系统模型，通过消息机制交流，

context有什么作用？
上下文，上层向下层传递内容（常用于 关闭后台协程）；阻塞

select作用？
阻塞；随机

阻塞？
atomic （原子操作）
<-make(chan int)
sync.Mutex（不可赋值, 不可重复上锁）
for{}
select{}
wg = sync.WaitGroup{}
wg.Add(num)
wg.Done()
wg.Wait()
runtime.Gosched() // 调度语句

一颗CPU，两个协程，其中一个协程在死循环，会发生什么？
1.14前跑死；以后不会，

go如何关闭协程？
上下文，cancel()调用 <-ctx.Done() （控制流）
close(ch)，广播

go协程池？
func worker(id int, jobCh <-chan int, retCh chan<- strint) {
    for job := range jobCh {
        ret := fmt.Sprintf("worker %d processed job: %d", id, job)
        retCh <- ret
    }
}

func workerPool(n int, jobCh <-chan int, retCh chan<- string) {
    for i := 0; i < n; i++ {
        go worker(i, jobCh, retCh)
    }
}

func genJob(n int) <-chan int {
    jobCh := main(chan int, n)
    go func() {
        for i := 0; i < n; i++ {
            jobCh <- i
        }
        close(jobCh)
    }
    return jobCh
}

func main() {
    jobCh := genJob(10)
    retCh := make(chan string, 200)
    workerPool(5, jobCh, retCh)

    close(retCh)
    for ret := range retCh {
        fmt.Println(ret)
    }
}

go的调度？
1.14后，协作式抢占调度，用户态的协程调度器

#############加法#############
a, b = 2, 3
def add(a,b):
    c = a&b<<1 #4
    d = a^b    #1

    while c&d: #0
        a,b = c,d
        c = a&b<<1 #是否有进位
        d = a^b    #不进位的

    return c | d #5

#############减法#############
def sub(a,b):
    return add(a, add(~b, 1)) #

cpu

内存：
    内核段：kernel
    用户段：app

调用：FC：方法内存地址调用（快）
      SC：系统调用（慢；安全）
 
中断：晶振，网卡（io设备）；IDT（中断向量表）

strace -ff -o out [go main] #跟踪系统调用
ls /proc #查看运行时的资源
进程：资源分配的最小单位
ls /proc/xxx/task #查看进程中的线程
线程：执行的最小单位，共享进程资源，栈空间独立

集群：一种物理形态：同一个业务部署到多个服务器，实现负载均衡，高可用
微服务：一种架构风格：大型复杂软件应用由一个或多个具有独立业务能力的微服务组成
分布式：一种工作方式：子业务通过一定的通信协议，完成一个完整的业务；属于微服务
C：一致性（强，弱，最终）
A：可用性
P：分区容错性（分布式：必然存在）
三者不可兼得
AP（常用，大不了最终失败）

网络间的通信就是进程间的通信
进程号PID<-socket（sip，sport，dip，dport，类型）<-（ip（协议号，端口号））<-帧<-比特流

netstat -nap | grep 8080
lsof -i:8080

nc -l ip port #开启监听
nc www.baidu.com #连接
curl www.baidu.com #连接加请求加断开
tcpdump -nn -i eth0 port 80 #监听eth0网卡上80端口的tcp进程

TIME-Wait和CLOSE-Wait
socket是全双工，关闭时四次挥手；
CLOSE-Wait：第二挥后，被动方进入，直到第三挥
作用：等待发送完成
TIME-Wait：第三挥后，主动方进入，第四挥后再等2MSL
作用：异常处理，解决网络丢包等不稳定带来的其他问题

web应用程序使用http协议传输，http是无状态协议。需要会话机制来记录
cookie
客户端记录确定用户信息，携带通行证建立连接，具有不可跨域名性；不安全，但可以加密；记住密码
session
服务端记录用户确认信息，sessionID在客户端；容易失效，

Redis淘汰策略？
默认策略，不淘汰任何key
LRU，LFU
随机淘汰，过期，TTL短的

Redis高可用？
主从复制：
哨兵模式：无法较好的进行水平扩展
集群模式：