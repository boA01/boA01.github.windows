1 数组中等于指定数的数字组合
a = [1, 1, 3, 5]
l = len(a)
n = 4

if n<a[0]:
    print(0)
elif n<a[-1] and :

else:
    for i in ragne(l):
        if arr.index(n-a[l]):
    print

2 列出字符串中所有字符出现字数 不允许用字典 count 
时间换空间一次迭代(leetcode做过 用字典哭死) 不会 
arr = 'jsljfls'
arr1 = sorted(arr)
方法一：
x = arr1[0]
for i in range(1,len(arr)):
    if x==arr1[i]:
        n+=1
    else:
        print(x, n)
        x = arr1[i]
方法二：
for i in set(arr):
    print(i,arr1.rindex(i)-arr1.index(i)+1)
方法三：
from collection import Counter
for i in Counter(arr).items()

3 装饰器解释  写一个运行时间装饰器 实现输出函数参数
import time

函数饰器
def decorator_args(d1=1): #接收装饰器参数
    def decorator(fn):
        def wrapper(*args, **kwargs):
            print(d1, d2) #打印装饰器参数
            print(args, kwargs) #打印方法参数
            start = time.time()
            fn(args, kwargs) #调用方法
            end = time.time()
            print(f"{fn.__name__} used: {end-start}")
        return wrapper
    return decorator

@decorator_args(2)
def fn1():.....
作用域：L(local：局部作用域)，E(nonlocal：嵌套作用域)，
       G(global：全局作用域)，B(build：内建)

类装饰器
class logger1():
    def __init__(self, fn): #接收方法
        self.fn = fn 
    def __call__(self, *args, **kwargs): #实现逻辑
        return self.fn(args, kwargs)

class logger2():
    def __init__(self, y=2): #接收装饰器参数
        self.y = y
    def __call__(self, func): #接收方法
        def wrapper(*args, **kwargs): #实现逻辑
            return self.fn(args, kwargs)
        return wrapper

#@logger1
@logger2(3)
def fn2():....

@staticmethod 静态方法
@classmethod 类方法
@property getter方法（只读）


单例模式
def dl(cls):
    def dl_wrapper(*args, **kwargs):
        # 如果没有实例
        if not dl_wrapper.instance():
            # 创建实例（类装饰器作用于__init__()）
            dl_wrapper.instance = cls(args, kwargs)
            return dl_wrapper.instance
        dl_wrapper.instance = None
    return dl_wrapper
@dl
class C1():
    .....

4 导包（import）之类的知识点。 做错了 
import *
from _ import _ [as xxx]
import xx as x <==> x = __import__('xx')

4、.*和.*?的区别
单字符匹配n次，贪婪匹配
满足条件的匹配一次，最小匹配

6、字典树
class Trie:
    # 初始化
    def __init__(self):
        self.root = {}
        self.end = "#"
 
    # 添加单词
    def add(self, word: str):
        node = self.root
        for char in word:
            node = node.setdefault(char, {})
        node[self.end] = None
 
    # 搜索单词是否存在
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node:
                return False
            node = node[char]
        return self.end in node

10、TCP三次握手，四次挥手的流程
1：请求建立连接
客户端--SYN=1,seq=A-->服务端；C：SYN_SENT
2: 对客户端的SYN确认应答，并请求建立连接
服务端--SYN=1,ACK=1,ack=A+1,seq=B-->客户端；S: SYN_RCVD
3: 对服务器的SYN确认应答
客户端--ACK=1,ack=B+1-->服务端；C：ESTABLISHED

SYN：同步标志位；ACK：确认标志位
seq：序号；ack：确认；
FIN：完成标志位；PSH：推送标志位，RST：重置标志位；URG：紧急标志位

1：请求断开连接
客户端--FIN=M-->服务端；C：FIN_WAIT1
2: 对客户端的FIN确认应答
服务端--ack=M+1-->客户端；S: CLOSE_WAIT，C：FIN_WAIT2
3: 请求断开
服务端--FIN=N-->客户端；S: LAST_ACK，C：TIME_WAIT
4：对服务器的FIN确认应答
客户端--ACK=1,ack=N+1-->服务端；S：CLOSED

11、TCP如何保证数据完整
可靠传输：差错控制，流量控制，拥塞控制

12、如何杀死 test.py进程（我说先用ps查看进程号，
然后kill -9 kill掉，然后就问我如何用一行命令杀死）
pgrep test.py |xargs kill -s 9
pkill -u test.py

13、快排的思路

2、给定一个a.txt，b.txt文件，里面存有许多ip地址，
现在判断有多少个相同的IP ?

5、TCP的重传机制、快速重传是怎样的 ?
重传机制：超时重传，选择重传，快速重传
快速重传：3次相同确认，立即重传

7、僵尸进程和孤儿进程的危害 ?
僵尸进程：父进程没给子进程收尸（没调用wait或者waitpid）
，子进程的进程描述符仍然保存在系统中；浪费有限的pid
孤儿进程：父进程结束了，子进程还在，将被init进程
(进程号为1)所收养；没什么大危害

8、统计在文件夹/root 下，包含“word”的文件的个数
ll | grep ".word." | wc -l

9、MySQL的调优

10、现有100亿个QQ号，如何快速判断某个QQ号是否在其中，
存储方式自己考虑，越快越好（运行时间），空间越小越好。

4、哈希表原理，哈希冲突怎么解决
使用哈希函数将关键码key转换为对应的数组下标；寻址容易，插入和删除困难；
解决：开放地址法；再哈希；链地址法；公共溢出区法
构造方法：除留余数法、平方取中法、随机数法、数字分析法、直接定址法、折叠法

5、二叉树的定义
树中节点的度不大于2的有序树

6、二叉树查找方式有哪些
先序遍历，中序遍历，后序遍历
深度优先，广度优先

8、数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用
场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道） ？
有序树：用于查找
哈夫曼树：带权路径最小的二叉树；电讯通信中，数据文件压缩
平衡二叉树（AVL）：左右子树树高不超过1；查找方便，windows对
进程地址空间的管理用到了AVL树
红黑树：根节点（黑），红黑相隔；插入删除方便，map和set都是
用红黑树实现的，linux中进程的调度用的是红黑树
B树：N叉（N-ary）平衡树，Balance(平衡)，每个节点可以存储多
个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点
B+树：叶子节点保存了完整的索引和数据，叶子节点类似于一个单链
表而非叶子节点只保存索引值；范围查询方便，适合做数据库索引，
这种需要持久化在磁盘
Trie树(字典树): 用在统计和排序大量字符串，如自动机

10、知道最小生成树吗
将图变成一颗最小权累加和的树

11、什么是元类
metaclass(元类)创建或魔改类
方法1、从type派生出来；
方法2、metaclass=基类，用基类__new__()构造对象

12、堆和栈的区别


13、什么是最小堆
二叉堆中：根节点
最大的为大根堆（最大堆），
最小的为最小堆。

14、动态规划是怎么解决问题的

15、会哪些排序算法，冒泡排序复杂度，稳不稳定

16、python内置的算法有哪些


最大回文字符串

http和https区别

ssl加密方法

字符串拼接方法哪个更快

指针和引用区别

4、有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧 
运行字节码的环境

5、解释器主要的功能是什么？ 
接收源代码，编译成字节码

6、GIL锁有了解吗，解释一下 
python的全局解释器锁，无法实现多线程并行，cpu利用率最大100%

7、协程和线程之间的区别 
协程：微线程，用户态，异步调用，多协程可以并行
线程：进程的实例，内核态，操作系统调度，同步机制，锁机制

8、进程切换和线程切换的区别 
进程切换涉及到虚拟地址空间的切换而线程切换则不会。
因为每个进程都有自己的虚拟地址空间，而线程是共享
所在进程的虚拟地址空间的，因此同一个进程中的线程
进行线程切换时不涉及虚拟地址空间的转换。

9、Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为
问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）
必选参数；默认参数；不定长参数，不定长关键字参数

11、Python中的迭代器是怎么用的 
next()方法遍历

12、你是怎么理解线程安全的 ？
因为多线程对共享的数据在时间片轮转存在非原子操作，需要线程同步机制，

13、有哪些进程间通信方式 ？
管道，信号，消息队列，共享内存，套接字

14、为了保证你刚才说的同步，有哪些方法呢（答了互斥锁和信号量，面试官
问还有别的吗，答可能还有信号）？
[互斥量（线程的）]，[管程，信号量，临界区，事件（进程的）]

17、有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），
有在Linux上调试过吗（无）？

19、在100个数中找第K大的数，如何实现（答的快排分治，用K和基准值比较决定往左
分支或右分支进行单支递归），还有其他的思路吗（思考后说了大根堆），讲一下大根
堆是什么（讲了大根堆的实现原理）？
大到小排序，然后遍历符合条件的

20、那你说一下字典的底层原理吧（讲了3.6前后的字典原理区别）
hash表，有序，方便查找

23、IP层分片重组是用来做什么的
不同网络的MTU不一样，所以要分片，分片后就要重组，

24、TCP拥塞控制是怎么做的
慢开始：开始为1，指数增长
拥塞避免：达到慢启动阈值，加法增长；拥塞直接降为1，阈值减半
快重传：3次重复确认，立即重传
快恢复：3次重复确认，阈值减半，加法增长；降低拥塞发生

25、文件系统中的软链接知道是什么吗（不知道）
快捷方式，是符号文件，记录目标文件的地址
硬链接：原文件起别名，硬链接文件与源文件共享iNode

26、现在有一个任务，最多只有10个线程在执行，如何实现？（答了线程池）
线程池具体怎么实现？那如果池子满了，其他任务该如何处理？还有别的思路吗？
（要求提示一下，面试官提示了用队列去实现，答了双端队列） 

2、什么是 LVS？
Linux 虚拟服务器，是一个虚拟的服务器集群系统

3、为什么需要用nginx反向代理
服务器安全；为负载均衡和动静分离提供实现支持

4、nginx如何实现负载均衡
轮询；加权；ip_hash；fair；url_hash

LVS：纯 4 层负载均衡，运行在内核态，性能是软件负载均衡中最高的。
Nginx：支持 4 层/7 层负载均衡，支持 HTTP、E-mail 协议。
HAproxy：是 7 层负载均衡软件，支持 7 层规则的设置，性能也不错。

API网关
    易于监控，易于认证，减少客户端与微服务的交互次数
    Zuul：
    Gateway：

6、keepalived是什么及作用?
是检测服务器的状态，服务器集群中自动化剔除和加入服务器

14、场景题，双十一高并发，阿里架构师推出的产品是怎么做的，给你做能想到哪些技术难点
（答了两个点，面试官问还有别的点吗，提示了数据库支撑不了，补充了中间件）
数据库
    读写分离：一主（写）多从（写）
    水平切分：

23、容器的作用，解决了什么问题?
服务运行的地方，高资源利用率与隔离，环境标准化和版本控制，持续部署与测试，跨云平台支持

2、python内存管理（详细介绍了GC三种方式以及底层实现，和内存池相关）

5、用过什么库？各自用来干什么？
numpy，
os，
sys，
collections

6、re用过？讲讲用过哪些正则？
re.search：扫描整个string找到第一个匹配然后返回
re.match：从头匹配一个符合规则的字符串
.group() 返回被 RE 匹配的字符串

.start() 返回匹配开始的位置
.end() 返回匹配结束的位置
.span()返回一个元组包含匹配 (开始,结束) 的位置

9、set了解么？和list的区别？底层如何实现的？
哈希map 

10、哈希如何处理冲突？
开放寻址，拉链，再哈希

11、ARP协议了解嘛，具体的运作方式？
地址解析协议；
RARP：反向地址解析协议
NDP：邻居发现协议，用于在IPv6中代替地址解析协议

14、第二次向同一个主机发送数据的时候还需要用ARP吗？
不用，有缓存

15、线程进程了解嘛？进程的调度？通讯方式？


16、python用哪个模块实现多线程？
import threading

17、数据结构了解嘛？讲一下数组和链表的区别？插入数据的话二者的复杂度？

18、排序和查找算法了解嘛？那些排序算法复杂度是nlogn？ 

19、单链表逆转下标由m到n之间的节点？

说说有哪些常见的漏洞？
SQL注入、XSS、CSRF

说说SMB协议？
微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为
Microsoft网络的通讯协议。SMB 是在会话层和表示层以及小部分应用层的协议。
SMB 改名为 CIFS

协议常见的攻击
中间人、重放 的原理、防御

快排和冒泡的比较（口述分别怎么实现的）？

2.装饰器，生成器，多线程 ？

3.列表和元组，字典的底层实现 ？
hashMap

4.最长公共前缀问题？

3、链表相关（合并，排序，反转）？

3、两道算法题（递归和动态规划）
（2）LC232.用栈实现队列
（3）LC40.组合总和2


5、Python了解哪些底层原理？

6、如果进程内存使用过高，可能有几个G，在Python该如何查找具体是哪一个
对象占用比较高（不会，就硬瞎说），通过哪个模块可以找到这些信息？

7、用__new__()这种魔法函数实现单例，写伪代码？
class C():
    _isnew = None #实例对象
    _isinit = False #是否被初始化

    def __new__(cls, *args, **kw):
        if not _isinit: #是否被构造
            cls._isnew = super.__new__(cls)
        return cls._isnew #返回对象

8、场景题：设计服务器，服务器只开了一个端口，但要在一分钟
内处理上万的请求，用Python该处理这种上万级的请求
流水线技能，客户端不必比及服务器端回来

9、浏览器输入URL全过程
浏览器缓存
域名解析(hosts-DNS)
向服务器发起tcp链接，与浏览器建立tcp三次握手；
握手成功后，浏览器想服务器发起http请求，拉取数据包；
服务器处理收到的请求，将处理的数据包返回到浏览器；
读取页面内容，浏览器渲染，解析html源码；
生成DOM树，解析css样式，js交互；

11、CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理

12、请求的响应速度过慢，如何分析排除出具体原因（面试官提示说
服务端的问题）

13、如何分析数据库慢查询，explan提示的字段有哪些，全表扫描
的话会type字段会显示什么

3.django，Flask，FastAPI的优缺点（项目相关）
优：是一个完整的Web开发框架；广泛应用，是最活跃
的生态系统非常丰富，有大量的第三方类匹配类库。
能够轻松地构建REST风格的API，而且因为它有模块化和可自定义的架构，
在前后端分离的趋势下，用Django构建Web API也很容易。
缺：Django Models没有mixins，只有简单的继承。

优：支持单元测试，而且由于它的内置开发服务器、集成支持等等，
所以可以通过调整扩展来过渡到Web框架。比Django更加灵活
缺：有一个单独的来源源，表明它将依次处理每个请求，所以不管有多少个请求，
flask仍然轮流处理，这样花费的时间更多

优：基于Python3.6+标准类型提示，支持异步，就像它的名字一样，
FastAPI是为了快速API而生的，快速，高效。与NodeJS和Go可以相提并论。
基于JSON Schema的Fast API(用来验证JSON数据结构的工具)、OAuth2.0
(用来授权的行业标准协议)和OpenAPI(可公开获得的应用程序编程接口)等
标准之上的；自动类型检查意味着减少了bug，而且Fast API可以验证开发
人员的数据类型，即使是在深层嵌套JSON请求中也是如此。
缺：因为FastAPI比较新，所以相对于其他框架，社区比较小，第三方教程也比较少。

7.python的数据结构有哪些
字典 数组（列表，元祖，字符串） 集合 自定义数据结构（类）
栈（append，pop） 队列（collections.deque）

8.python切片
[开始:结束:步长] 越界不报错

9.元组和列表的异同
元祖：()，不可变
列表：[]，可变

10.手撕快排，并解释
# 按基准值，左大右小摆放，分而治之
def quick_sort(arr):
    if len(arr)>1: #递归入口
        mid = arr[0] #基值
        l, r = [], []
        arr.remove(mid)
        for i in arr:
            if i>mid:
                r.append(i) #大于基准值放右边
            else:
                l.append(i) #小于基准值放左边
        return quick_sort(l) + [mid] + quick_sort(r)
    else:
        return arr


Python垃圾回收机制，内存机制？
引用计数（sys.getrefcount()-1）为主，
标记清除(解决交叉引用)和分代回收(解决前者效率问题，gc.collect()可触发)为辅
内存管理机制为Pymalloc（内存池（如小整数池））
import psutil

读取大文件
def read_big_file(f_name, size=1024):
    with open(f_name, 'r') as fp:
        while txt := fp.read(size): #3.8+
            yield txt


arr = [1,0,3,1,52,3,0]

#本位与后面位比较，确定本位
def select_sort(arr):
    for i in range(len(arr)-1,0,-1):
        for j in range(i):
            if arr[i]<arr[j]:
                arr[i],arr[j]=arr[j],arr[i]
    return arr

# 两两比较，确定末位
def bubble_sort(arr):
    for i in range(len(arr)-1, 1, -1):
        flag = True
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1]=arr[j+1], arr[j]
                flag = False
        if flag:
            break
    return arr

# 按基准值，左大右小摆放，分而治之
def quick_sort(arr):
    if len(arr)>1: #递归入口
        mid = arr[0] #基值
        l, r = [], []
        arr.remove(mid)
        for i in arr:
            if i>mid:
                r.append(i) #大于基准值放右边
            else:
                l.append(i) #小于基准值放左边
        return quick_sort(l) + [mid] + quick_sort(r)
    else:
        return arr
qsort=lambda l:l if len(l)<=1 else qsort([x for x in l[0] if x<=l[0]])+[l[0]]+qsort([y for y in l[1:] if y>l[0]])

#
def insertion_sort(arr):
    # 从数据第二个元素开始循环，直到最后一个元素
    for i in range(1, len(arr)):
        # 这个是我们想要放在正确位置的元素
        key_item = arr[i]
        # 初始化变量，用于寻找元素正确位置
        j = i - 1
        # 遍历元素左边的列表元素，一旦key_item比被比较元素小，那么找到正确位置插入。
        while j >= 0 and arr[j] > key_item:
            # 把被检测元素向左平移一个位置，并将j指向下一个元素（从右向左）
            arr[j + 1] = array[j]
            j -= 1
        # 当完成元素位置的变换，把key_item放在正确的位置上
        arr[j + 1] = key_item
    return arr
if __name__ == '__main__':
    # print(bubble_sort(arr))
    print(quick_sort(arr))

# 单例模型
#__new__()
class Single():
    def __new__(cls):
        if not hasattr(cls, "_instance"):
            cls._instance = super().__new__(cls)
        return cls._instance

# 工厂模式
class Dog():
    def __init__(self, *args, **kwargs):
        pass
class Cat():
    def __init__(self, *args, **kwargs):
        pass

def fac(animal):
    if animal.lower()=='dog':
        return Dog()
    elif animal.lower()=='cat':
        return Cat()
    else:
        print("工厂没模具")

结构性模式
    # 构造模式

    # 适配器模式
    翻译官的样子；原本由于接口不兼容而不能一起
    工作的那些类使他们可以一起工作。

    # 装饰器模式
    钢铁战甲的样子；动态的给对象加额外的功能，
    相比生成子类更灵活。

    # 桥接模式
    刷脸支付的样子；抽象部分与实现部分分离，
    使他们可以独立变化。

    # 代理模式
    ；为其他对象提供一种代理以控制这个对象的访问。

行为模式
    责任链
    迭代器
    中介者

瀑布模型：
    自上而下，相互衔接的固定顺序；适用于需求明确且有经验或案例的项目
    优点：可以规范过程，利于评审
    缺点：过于理想，缺乏灵活性，容易产生需求偏差
旋转模型：
    增加了风险预测；适合大型复杂系统
v模型：
敏捷开发：
DevOps：CICD（持续交付，持续部署）

PV
临界区：进程访问临界资源的那段代码
信号量：同步，互斥
P：使s=s-1，s>=0，该进程继续执行；否则进等待队列
V：使s=s+1；s<=0，唤醒等待队列中的一个进程
                    同步模型
单缓冲区：s1 = 1，s2 = 0
生产者                        消费者
生产一个产品：P(s1)            消费一个产品：P(s2) 
放入市场：V(s2)                缓冲区：V(s1)
                    互斥模型
P(S)
...
V(S)
...

流水线：
    总时间=T+(k-1)t T：一个完整任务时间，t：最长子任务时间
    吞吐率=任务数/总时间<=1/max(t1,t2,t3...)
    加速比=kT/总时间

甘特图：并行显示明显；
PERT（计划流程图）：清晰看见依赖关系。


通信子网：通信节点（集线器，交换机，路由器等）和通信链路（电话线，光纤）
资源子网：PC，服务器等

拓扑结构：总线，星型，环型，树型，全网型，不规则型

时域反射仪TDR：电缆
光时域反射仪OTDR：光纤

单极性：高：1
双极性：+：0，-：1
曼彻斯特：1：低到高；具有同步能力；10M以太网
差分曼彻斯特：1：不变，0：变；令牌环网
两者利用率50%

DPSK：N=2
QPSK：N=4

PCM: 数据速率=每秒采帧次数*每次传输数据

W=fmax-fmin

奈奎斯特定理：
    码元传输速率B=2W
    极限数据传输速率=Blog2 N
香农定理：
    信噪比=>响度=10lg(S/N)
    极限数据传输速率=W*log2 (1+S/N)


多路复用
空分复用（SDM）：
频分复用（FDM）：频道
波分复用（WDM）：光纤
时分复用（TDM）：
码分复用（CDMA）：

T1：1.544Mbps
E1：2.048Mbps,32个8位数据样本组成125us的基本帧，（CH0和CH16）用于控制指令，其余用于语音传送。

局域网标准
802.11:无线局域网标准
  CSMA/CA：
    冲突避免
    隐藏结点
    WEP  RC4
    WPA  RC4+TKIP
    WPA2 TKIP/AES CCMP
802.3:有线
  CSMA/CD介质接入控制方法和物理层技术规范
    载波侦听，多路复用
    冲突检测：传输时延>=2*传播时延（2τ）
    发现冲突，停止发送：16

802.4:令牌总线网标准
802.5:令牌环网标准

无线局域网
AC+瘦AP
胖AP
无线接入点：
    室外AP
    高密AP
    分布式AP（母AP互联）
    墙面AP（POE交换机互联）

电路交换：ADSL
报文交换
分组交换：
    虚电路（X.25，帧中继（FR），ATM）
    数据包（ip数据包）

交换机：
    存储转发式交换：完整接收数据帧，缓存、验证、碎片过滤，然后转发，
        优点：可以提供差错校验和非对称交换
        缺点：延迟大
    直通式交换：输入端口扫描到目标地址后立即转发
        优点：延迟小，交换速度快 
        缺点：没有检错能力，不能实现非对称交换
    碎片过滤式交换：转发时看数据包是否够64B，小于就说明时冲突碎片，
    丢弃；否则转发

    VLAN：现在4094个

    接口：以太网接口（LAN，WAN）

级联：一根双绞线连接不同厂家的交换机
堆叠：专用的堆叠模块和堆叠线缆，只能自家设备间连接，可以当一个整体；菊花链，星型

以太网帧结构（二层封装）
    目的地址，源地址：MAC地址
    校验位：CRC 异或
    最小长度：64B，最大长度：1518B
    MTU：最短46，最长1500
    数据传输最高效率=1500/1518~=98.8%
HDLC：0比特填充技术（思科协议，默认WAN口封装协议）
    帧边界"01111110"
    信息帧（I帧）
    监控帧（S帧）
    无编号帧（U帧）
    REJ3：回退到3
    SREJ3：重传3
PPP：点到点协议（PAP：明文传输，DHAC：MD5摘要算法（单向））

对称加密：
    DES：密钥：56位，密文：64位
    3DES：密钥：112位
    IDEA：密钥：128位
    AES：密钥：128，192或256位
    RC4：流加密，加密快，常用于WIFI
非对称加密：
  公钥加密：
    RSA：
    DH：
    公钥加密，私钥解密    保密通信
    私钥加密，公钥解密    数字签名：抗抵赖性
        数字证书：包含接收方的公钥和CA的私钥进行的签名
摘要算法：数据完整性，单向性，防止篡改
    MD5：按512分组，生成128位hash值
    SHA：按512分组，生成160位hash值

VPN：虚拟专用网；替换源，目的ip
    远程访问vpn：个人到企业（vpn服务器分发ip）
    点到点vpn：企业间安全连接

    二层：L2TP，PPTP（基于PPP；常用翻墙；tcp1723）
    三层：IPSec和GRE（常用点到点vpn）
    四层：SSL，TLS  （常用安全连接）
IPSec：（先路由，再NAT（deny：nat豁免），后IPSec）
    两种模式：
        传输模式：速度快 End-to-End
        隧道模式：更安全 Site-to-Site
    两阶段：
      管理连接：
          因特网密钥交换协议（IKE）：用于密钥生成和分发（DH）
            conf t 
            crypto isakmp policy 1 #创建传输集/策略集
              encryption des/3des/aes
              hash md5/sha
              group 1/2/5
              authentication pre-share
              lifetime 秒 (默认86400s)
              exit
            crypto isakmp key 预共享秘钥 address 对方公网ip
      数据连接：
          认证头（AH）：提供数据完整性与数据源认证，采用摘要算法
          封装安全负荷（ESP）：提供数据加密+完整性和认证
            access-list 101 permit ip 源网段 目的网段  #定义vpn触发流量（ACL表）
            crypto ipsec transform-set 传输模式名 esp-des/3des/aes esp/ah-md5/sha-hmac #加密及认证
        conf t 
        crypto map map名 1 isakmp #创建map映射表
          match address 101（acl表名）
          set transform-set 传输模式名
          set peer 目的公网ip
          exit
          crypto map map名 2 isakmp #创建map映射表
          match address 102（acl表名）
          set transform-set 传输模式名
          set peer 目的公网ip
          exit
        interface f0/1(外网接口)
          crypto map map名 #应用map表（一个接口只能一个map表）
          exit
      show crypto isakmp sa #查第一阶段状态
      show crypto ipsec sa #查第二阶段状态
      show crypto isakmp policy #查看第一阶段策略配置
      show crypto ipsec transform-set #查看第二阶段传输模式
SSL（安全套接层）：
    SSL握手协议
    SSL改变密码协议
    SSL警告协议
https：安全的超文本传输协议；使用ssl的TCP，全程加密
S-HTTP：仅对数据加密，http形式传输

PGP：完整的电子邮件安全软件包

入侵防御系统IPS：串行部署；能检测，还能自动防御
防火墙FW（WAF：web防火墙）：区域隔离（DMZ，内网，外网，Loacl（自己，优先级最高）），访问控制
入侵检测系统IDS：旁路部署；异常检测，误用检测和混合检测；记录日志并报告

SQL注入：
XSS：跨站脚本攻击
CSRF：跨站请求伪造
一句话木马：eval()
木马：C&C
APT：高级可持续攻击，逐步渗透

4K->12B->HHH

RAID：独立磁盘冗余阵列
    作用：提高读写性能和数据安全性
    分块 条带 热备 重构
    1.0：多对一重构
    2.0：多对多重构，负载均衡
    备份：完全 增量 差量

磁盘阵列
    DAS：块级    通用
存储数据网络
    NAS：文件级  文件服务器
    FC-SAN：块级 数据库应用 光纤交换机连接
    IP-SAN：块级 视频监控

路由器：
    接口：
        Serial：帧中断
        RJ-45：双绞线以太网

三层网络架构
    出口层：广域网接入，带宽控制，出口策略
    核心层：高速转发[，服务器接入，路由选择]
    汇集层：流量汇聚，链路冗余，设备冗余，路由选择，访问策略
    接入层：提供接口，安全准入，访问控制，端口安全配置

xDSL：接入技术（x:H，S对称的，其余非对称 ）
AON:有源光网络
[A,E,G]PON:无源光网络

长度
    帧头:14B
    MTU：ip总长度
    ipv4:20B-60B IHL(5——15)
    ipv6:40B
    UDP:8B
    TCP:20B-40B
    帧尾:4B

ipv4：
    标志：DF（是否可分片），MF（是否有分片）
    偏移量：偏移字节序号/8
    生存期TTL：8B 255

ipv6:
    单播：不确定地址 :: ，回环地址 ::1
    任播：只能给路由器
    组播：代替广播
    没有广播

隧道技术：v6之间通过v4进行通信
    6 to 4
双栈技术：同时运行v4和v6
翻译技术：解决纯v6与纯v4间通信


TCP：面向连接的可靠传输协议
    协议号：6
UDP：非面向连接的不可靠协议
    协议号：17

ICMP网间控制报文协议:
  协议号：1
  差错报告：
    ping：TTL，路由计数
    traceroute/tracert：路由跟踪

IP:
    类型：0x0800

ARP：地址解析协议；IP转MAC
    类型：0x0806
    原理：
        1.发送广播请求
        2.接收单播应答 
    ARP攻击，欺骗：
        伪造mac，断网
        冒充mac，中间人
    防御：
        1.静态ARP绑定
        2.ARP防火墙（小网，否则网关崩溃）
        3.硬件防御（交换机上arp绑定）

RARP：反向地址解析协议
NDP：邻居发现协议，用于在IPv6中代替地址解析协议

帧头：
    目的MAC 
    源MAC
    类型

DNS：域名系统；域名转IP
    浏览器缓存
    系统缓存 #ipconfig /displaydns
    hosts记录
    本地DNS服务器查询
    递归查询（老好人）<本地，中介域名服务器>
    迭代查询（踢皮球）<根，顶级，授权(多数)域名服务器等>
    ipcofnig /displaydns #查看缓存
    ipconfig /flushdns #清除缓存
    nslookup #诊断域和查看
    linux下 Bind组件 搭建DNS服务器 主配置文件named.conf
    树形层次化结构
    >>>UDP封装<<<
    
    攻击：
      DNS劫持

DHCP：自动分配ip
    客户端：DHCP Discover(广播)，寻找DHCP服务器
    服务端：DHCP Offer(单播)，携带分配的ip
    客户端：DHCP Request(广播)，告知服务端，使用某ip
    服务端：DHCP Ack(单播)，最终确认，告知客户端可以使用该ip
    思科全是广播
    DHCP中继：广播转单播（路由器隔广播）
    主配置文件dhcpd.conf
    ipconfig /release #释放ip地址
    ipconfig /renew #重新获取ip

    攻击：
      耗尽ip；交换机（管理型）动态mac地址绑定
      伪装DHCP服务器；路由器接口管理，（除dhcp服务器端口不能发送offer）
    

FTP：
    匿名登录：anonymous
    主动模式：服务器（20）主动连接客户端
    被动模式：客户端连接服务器一个端口（高位端口）

IIS：
    web，ftp，smtp（没有POP3和MAP）

CND：内容分发网络；就近访问节点，提高响应速度和命中率

SNMP：UDP承载
    客户端：161，接收get/set
    服务端：162，接收trap
    效率高，不可靠
    v2:增加了管理站之间通信和数据块检索
    v3：加入了网络管理框架和安全机制；
        没解决拒绝服务和通信分析

虚拟存储：辅存当内存

华为设备配置
    system-view #进入系统
    sysname Switch1 #设备重命名
    ip route-static 0.0.0.0 0 12.1.1.1 preference 50 #配置静态路由，并且自定义优先级50
    ip routing-table #查看路由表
    ip address x.x.x.x 24 配置ip

    display current-configuration #查看全局配置

    ##########
    规则：acl x; rule 10 permit ip source ...
    流分类：trallic classifier n; if-match acl x
    流行为：trallic behavior re-xxx; redirect ip-nexthop x.x.x.x
    流策略：trallic policy p; classifier 分类n behavior 行为m
    用策略：trallic-policy p inbound

    bfd #开启bfd
    bfd xxx bind peer-id 目的ip source-ip 源ip auto #监测xxx
    ip route-static 0.0.0.0 0 12.1.1.1 preference 50 track bfd-session xxx #设置静态路由

    
    #########VLAN
    valn 10 #创建valn10
    vlan 【batch】 10 20 #批量创建vlan
    interface 【gigabitethernet】 0/0/1 #进入接口
    port link-type [access] #接口模式设置为access
    prot [default] vlan 10 #划入vlan10

    prot link-type trunk #接口模式设置为trunk
    prot [trunk] allow-pass valn all #开启trunk 

    【interface】 vlanif 10 #进入三层vlanif接口
    ip address ip 掩码 #设置网段
    vrrp vrid 10 virtual-ip 192.168.10.254 priority 120 #自定义优先级

    #########STP
    stp enable #开启服务
    stp mode mstp #多生成树协议
    stp regin-configuration #
    region-name 1
    instance 20 valn 10
    active region-configuration
    stp instance 20 root primary
    stp instance 20 root secondary

    ###########DHCP
    system-view
    dhcp enable #开启dhcp服务
    ip 【pool】 1 #创建ip地址池1
    network 10.1.1.0 mask (25)255.255.255.128 #配置ip范围
    gateway-list 10.1.1.1 #配置网关
    dns-list 10.1.1.1 #配置DNS
    【excluded-ip-address】 10.1.1.2 #保留ip地址
    excluded-ip-address 10.1.1.4 10.1.1.6 #保留ip地址段
    【lease】 day 10 #配置租期
    quit
    ...
    dhcp select global/interface #全局或接口dhcp服务器

    ##########RIP
    rip
    version 2
    network 192.168.30.0 #宣告网段

    ##########OSPF
    ospf 1 #
    area 0 #区域0（主干区域）
    network 192.168.1.0 0.0.0.255 #宣告192.168.1.0网段
    return #
    
    ospf peer brief #查看状态
    display ospf peer #查看邻居信息
    display ospf biref #概要信息
    display ospf routinf #路由表信息

    ##########Telnet
    telnet server 【enable】 #开启telnet
    【user-interface】 vty 0 4 #进入虚拟接口0-4
    protocol 【inbound】 telnet #透过telnet协议登录
    authentication-mode aaa #认证方式为aaa
    aaa #启用aaa
    local-user admin123 password admin123 #配置用户名和密码
    local-user admin123 service-type telnet #用户用于telnet
    local-user admin123 privilege level 15 #用户等级

    #############ACL（2000-2999 普通ACL，只能使用源IP地址；3000-3999是高级ACL，destination 目的地）
    time-range workday 8:30 to 18:30 working-day #设置时段
    acl 2000 #启用2000编号的ACL
    rule 【permit】 source 192.168.1.10 0 time-range workday #允许当前ip在工作日使用
    rule 【deny】 #可以不写
    user-intervace vty 0 4 #进入虚拟接口0-4
    acl 2000 inbound #应用ACL


    rule 10 deny ip source 172.16.4.13 0
    rule 10 deny ip source 172.16.4.13 0 【destination】172.16.3.0 0.0.0.255

    ##############NAT （snat 内网访问外网；dnat 服务器映射）
    nat address-group 1 2.2.2.100 2.2.2.200 #配置NAT地址池1
    nat address-group 2 2.2.2.80 2.2.2.83 #配置NAT地址池2

    acl 2000 #配置ACL2000 （2000-2999 普通ACL，只能使用源IP地址）
    rule 5 【permit】 source 192.168.20.0 0.0.0.255 #配置为5的规则
    quit
    acl 2001 #配置ACL2001
    rule 5 【permit】 source 10.0.0.0 0.0.0.255 #匹配上述地址
    quit

    interface gigabitethernet 3/0/0 #进入接口

    nat outbound 2000 address-group 1 no-pat #设置ACL2000匹配的源地址，转换为地址池1的地址，不开启 端口转换
    nat outbound 2001 address-group 2 #设置ACL2001匹配的源地址，转换为地址池2的地址，默认开启端口转换（NAPT）

    nat static global 122.1.2.1 inside 192.168.1.1 #静态绑定
    
    nat outbound 2000 #配置端口ip（Easy IP是一种特殊napt，只能映射一个ip）
    
    nat server protocol tcp global 202.10.10.1 www inside 192.168.10.1 8080 #端口映射

    quit #退出当前视图，返回上一级

掩码：IP，DHCP
反掩：ACL，NAT，OSPF

以太网传输效率
    1518*8/100Mb/s=121.44us=发送时间
    2000m/200m/us=10us=传播时间
    64*8/100Mb/s=5.12us=确认帧发送时间
    121.44+5.12+10*2=146.56us=总时间
    1518*8b/146.56us=82.86Mb/s

域: 集中管理
    1）域控制器 DC（Domain Controller）
    2）成员机

    活动目录 AD（Active Directory）
    组策略 GPO 


#############加法#############
a, b = 2, 3
def add(a,b):
    c = a&b<<1 #4
    d = a^b    #1

    while c&d: #0
        a,b = c,d
        c = a&b<<1 #是否有进位
        d = a^b    #不进位的

    return c | d #5

#############减法#############
def sub(a,b):
    return add(a, add(~b, 1)) #


