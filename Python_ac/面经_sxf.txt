1 数组中等于指定数的数字组合 不会
a = [1, 1, 3, 5]
l = len(a)
n = 4

if n<a[0]:
    print(0)
elif n<a[-1] and :

else:
    for i in ragne(l):
        if arr.index(n-a[l]):
    print

2 列出字符串中所有字符出现字数 不允许用字典 count 
时间换空间一次迭代(leetcode做过 用字典哭死) 不会 
arr = 'jsljfls'
arr1 = sorted(arr)
方法一：
x = arr1[0]
for i in range(1,len(arr)):
    if x==arr1[i]:
        n+=1
    else:
        print(x, n)
        x = arr1[i]
方法二：
for i in set(arr):
    print(i,arr1.rindex(i)-arr1.index(i)+1)
方法三：
from collection import Counter
for i in Counter(arr).items()

3 装饰器解释  写一个运行时间装饰器 实现输出函数参数
import time

函数饰器
def decorator_args(d1=1): #接收装饰器参数
    def decorator(fn):
        def wrapper(*args, **kwargs):
            print(d1, d2) #打印装饰器参数
            print(args, kwargs) #打印方法参数
            start = time.time()
            fn(args, kwargs) #调用方法
            end = time.time()
            print(f"{fn.__name__} used: {end-start}")
        return wrapper
    return decorator

@decorator_args(2)
def fn1():.....
作用域：L(local：局部作用域)，E(nolocal：嵌套作用域)，
       G(global：全局作用域)，B(build：内建)

类装饰器
class logger1():
    def __init__(self, fn): #接收方法
        self.fn = fn 
    def __call__(self, *args, **kwargs): #实现逻辑
        return self.fn(args, kwargs)

class logger2():
    def __init__(self, y=2): #接收装饰器参数
        self.y = y
    def __call__(self, func): #接收方法
        def wrapper(*args, **kwargs): #实现逻辑
            return self.fn(args, kwargs)
        return wrapper

#@logger1
@logger2(3)
def fn2():....

@staticmethod 静态方法
@classmethod 类方法
@property getter方法（只读）


单例模式
def dl(cls):
    def dl_wrapper(*args, **kwargs):
        # 如果没有实例
        if not dl_wrapper.instance():
            # 创建实例（类装饰器作用于__init__()）
            dl_wrapper.instance = cls(args, kwargs)
            return dl_wrapper.instance
    dl_wrapper.instance = None
    return dl_wrapper
@dl
class C1():
    .....

4 import之类的知识点。 做错了 
import *
from _ import _

5手撕快排 直接秒杀 


4、.*和.*?的区别
单字符匹配n次，贪婪匹配
满足条件的匹配一次，最小匹配

6、字典树
class Trie:
    # 初始化
    def __init__(self):
        self.root = {}
        self.end = "#"
 
    # 添加单词
    def add(self, word: str):
        node = self.root
        for char in word:
            node = node.setdefault(char, {})
        node[self.end] = None
 
    # 搜索单词是否存在
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node:
                return False
            node = node[char]
        return self.end in node

10、TCP三次握手，四次挥手的流程
1：请求建立连接
客户端--SYN=1,seq=A-->服务端；C：SYN_SENT
2: 对客户端的SYN确认应答，并请求建立连接
服务端--SYN=1,ACK=1,ack=A+1,seq=B-->客户端；S: SYN_RCVD
3: 对服务器的SYN确认应答
客户端--ACK=1,ack=B+1-->服务端；C：ESTABLISHED

SYN：同步标志位；ACK：确认标志位
seq：序号；ack：确认；
FIN：完成标志位；PSH：推送标志位，RST：重置标志位；URG：紧急标志位

1：请求断开连接
客户端--FIN=M-->服务端；C：FIN_WAIT1
2: 对客户端的FIN确认应答
服务端--ack=M+1-->客户端；S: CLOSE_WAIT，C：FIN_WAIT2
3: 请求断开
服务端--FIN=N-->客户端；S: LAST_ACK，C：TIME_WAIT
4：对服务器的FIN确认应答
客户端--ACK=1,ack=N+1-->服务端；S：CLOSED

11、TCP如何保证数据完整
可靠传输：差错控制，流量控制，拥塞控制

12、如何杀死 test.py进程（我说先用ps查看进程号，
然后kill -9 kill掉，然后就问我如何用一行命令杀死）
pgrep test.py |xargs kill -s 9
pkill -u test.py

13、快排的思路

2、给定一个a.txt，b.txt文件，里面存有许多ip地址，
现在判断有多少个相同的IP ?

5、TCP的重传机制、快速重传是怎样的 ?
重传机制：超时重传，选择重传，快速重传
快速重传：3次相同确认，立即重传

7、僵尸进程和孤儿进程的危害 ?
僵尸进程：父进程没给子进程收尸（没调用wait或者waitpid）
，子进程的进程描述符仍然保存在系统中；浪费有限的pid
孤儿进程：父进程结束了，子进程还在，将被init进程
(进程号为1)所收养；没什么大危害

8、统计在文件夹/root 下，包含“word”的文件的个数
ll | grep ".word." | wc -l

9、MySQL的调优

10、现有100亿个QQ号，如何快速判断某个QQ号是否在其中，
存储方式自己考虑，越快越好（运行时间），空间越小越好。

4、哈希表原理，哈希冲突怎么解决
使用哈希函数将关键码key转换为对应的数组下标；寻址容易，插入和删除困难；
解决：开放地址法；再哈希；链地址法；公共溢出区法
构造方法：除留余数法、平方取中法、随机数法、数字分析法、直接定址法、折叠法

5、二叉树的定义
树中节点的度不大于2的有序树

6、二叉树查找方式有哪些
先序遍历，中序遍历，后序遍历
深度优先，广度优先

8、数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用
场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道） ？
有序树：用于查找
哈夫曼树：电讯通信中，数据文件压缩
平衡二叉树（AVL）：左右子树树高不超过1，查找方便；windows对进程地址空间的管理用到了AVL树
红黑树：根节点（黑），红黑相隔，插入删除方便，map和set都是用红黑树实现的，linux中进程的调度用的是红黑树
B/B+树：N叉（N-ary）平衡树；适合做数据库索引这种需要持久化在磁盘
Trie树(字典树): 用在统计和排序大量字符串，如自动机

10、知道最小生成树吗
将图变成一颗最小权累加和的树

11、什么是元类
metaclass(元类)创建或魔改类
方法1、从type派生出来；
方法2、metaclass=基类，用基类__new__()构造对象

12、堆和栈的区别


13、什么是最小堆

14、动态规划是怎么解决问题的

15、会哪些排序算法，冒泡排序复杂度，稳不稳定

16、python内置的算法有哪些


最大回文字符串

http和https区别

ssl加密方法

字符串拼接方法哪个更快

指针和引用区别

4、有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧 
运行字节码的环境

5、解释器主要的功能是什么？ 
接收源代码，编译成字节码

6、GIL锁有了解吗，解释一下 
python的全局解释器锁，无法实现多线程并行，cpu利用率最大100%

7、协程和线程之间的区别 
协程：微线程，用户态，异步调用，多协程可以并行
线程：进程的实例，内核态，操作系统调度，同步机制，锁机制

8、进程切换和线程切换的区别 
进程切换涉及到虚拟地址空间的切换而线程切换则不会。
因为每个进程都有自己的虚拟地址空间，而线程是共享
所在进程的虚拟地址空间的，因此同一个进程中的线程
进行线程切换时不涉及虚拟地址空间的转换。

9、Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为
问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）
必选参数；默认参数；不定长参数，不定长关键字参数

11、Python中的迭代器是怎么用的 
.next()方法遍历

12、你是怎么理解线程安全的 ？
因为多线程对共享的数据在时间片轮转存在非原子操作，需要线程同步机制，

13、有哪些进程间通信方式 ？
管道，信号，消息队列，共享内存，套接字

14、为了保证你刚才说的同步，有哪些方法呢（答了互斥锁和信号量，面试官
问还有别的吗，答可能还有信号）？
[互斥量（线程的）]，[管程，信号量，临界区，事件（进程的）]

17、有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），
有在Linux上调试过吗（无）？

19、在100个数中找第K大的数，如何实现（答的快排分治，用K和基准值比较决定往左
分支或右分支进行单支递归），还有其他的思路吗（思考后说了大根堆），讲一下大根
堆是什么（讲了大根堆的实现原理）？
大到小排序，然后遍历符合条件的

20、那你说一下字典的底层原理吧（讲了3.6前后的字典原理区别）
hash表，有序，方便查找

23、IP层分片重组是用来做什么的
不同网络的MTU不一样，所以要分片，分片后就要重组，

24、TCP拥塞控制是怎么做的
慢开始：开始为1，指数增长
拥塞避免：达到慢启动阈值，加法增长；拥塞直接降为1，阈值减半
快重传：3次重复确认，立即重传
快恢复：3次重复确认，阈值减半，加法增长；降低拥塞发生

25、文件系统中的软链接知道是什么吗（不知道）
快捷方式，是符号文件，记录目标文件的地址
硬链接：原文件起别名，硬链接文件与源文件共享iNode

26、现在有一个任务，最多只有10个线程在执行，如何实现？（答了线程池）
线程池具体怎么实现？那如果池子满了，其他任务该如何处理？还有别的思路吗？
（要求提示一下，面试官提示了用队列去实现，答了双端队列） 

29、算法题：力扣21 - 合并两个有序链表，手撕 


3、为什么需要用nginx反向代理
服务器安全；为负载均衡和动静分离提供实现支持

4、nginx如何实现负载均衡
轮询；加权；ip_hash；fair；url_hash

14、场景题，双十一高并发，阿里架构师推出的产品是怎么做的，给你做能想到哪些技术难点
（答了两个点，面试官问还有别的点吗，提示了数据库支撑不了，补充了中间件）
数据库
    读写分离：一主（写）多从（写）
    水平切分：

19、自己想要达到的程度
20、如果涉及其他语言的项目，学习能力如何
21、职业规划
22、除了Python外还需要什么技能
23、容器的作用，解决了什么问题
服务运行的地方，高资源利用率与隔离，环境标准化和版本控制，持续部署与测试，跨云平台支持

2、python内存管理（详细介绍了GC三种方式以及底层实现，和内存池相关）

3、装饰器有用过么？（staticmethod和自己写的时间戳装饰器）

4、进一步： staticmethod讲一下？和其他类成员函数的区别？

5、用过什么库？各自用来干什么？
numpy，
os，
sys，
collections

6、re用过？讲讲用过哪些正则？
re.search：扫描整个string找到第一个匹配然后返回
re.match：从头匹配一个符合规则的字符串

.group() 返回被 RE 匹配的字符串
.start() 返回匹配开始的位置
.end() 返回匹配结束的位置
.span()返回一个元组包含匹配 (开始,结束) 的位置

8、深浅拷贝？详细说一下？


9、set了解么？和list的区别？底层如何实现的？
哈希map 

10、哈希如何处理冲突？
开放寻址，拉链，再哈希 

11、ARP协议了解嘛，具体的运作方式？
地址解析协议；
RARP：反向地址解析协议
NDP：邻居发现协议，用于在IPv6中代替地址解析协议

14、第二次向同一个主机发送数据的时候还需要用ARP吗？
不用，有缓存

15、线程进程了解嘛？进程的调度？通讯方式？


16、python用哪个模块实现多线程？
import threading

17、数据结构了解嘛？讲一下数组和链表的区别？插入数据的话二者的复杂度？

18、排序和查找算法了解嘛？那些排序算法复杂度是nlogn？ 

19、单链表逆转下标由m到n之间的节点？

说说有哪些常见的漏洞？
SQL注入、XSS、CSRF

说说SMB协议？
微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为
Microsoft网络的通讯协议。SMB 是在会话层和表示层以及小部分应用层的协议。
SMB 改名为 CIFS

协议常见的攻击
中间人、重放 的原理、防御

快排和冒泡的比较（口述分别怎么实现的）？

2.装饰器，生成器，多线程 ？

3.列表和元组，字典的底层实现 ？
hashMap

4.最长公共前缀问题？

3、链表相关（合并，排序，反转）？

3、两道算法题（递归和动态规划）
（2）LC232.用栈实现队列
（3）LC40.组合总和2


5、Python了解哪些底层原理？

6、如果进程内存使用过高，可能有几个G，在Python该如何查找具体是哪一个
对象占用比较高（不会，就硬瞎说），通过哪个模块可以找到这些信息？

7、用__new__()这种魔法函数实现单例，写伪代码？
class C():
    _isnew = None #实例对象
    _isinit = False #是否被初始化

    def __new__(cls, *args, **kw):
        if not _isinit: #是否被构造
            cls._isnew = super.__new__(cls)
        return cls._isnew #返回对象

8、场景题：设计服务器，服务器只开了一个端口，但要在一分钟
内处理上万的请求，用Python该处理这种上万级的请求
流水线技能，客户端不必比及服务器端回来

9、浏览器输入URL全过程
浏览器缓存
域名解析(hosts-DNS)
向服务器发起tcp链接，与浏览器建立tcp三次握手；
握手成功后，浏览器想服务器发起http请求，拉取数据包；
服务器处理收到的请求，将处理的数据包返回到浏览器；
读取页面内容，浏览器渲染，解析html源码；
生成DOM树，解析css样式，js交互；

11、CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理

12、请求的响应速度过慢，如何分析排除出具体原因（面试官提示说
服务端的问题）

13、如何分析数据库慢查询，explan提示的字段有哪些，全表扫描
的话会type字段会显示什么

3.django，Flask，FastAPI的优缺点（项目相关）
优：是一个完整的Web开发框架；广泛应用，是最活跃
的生态系统非常丰富，有大量的第三方类匹配类库。
能够轻松地构建REST风格的API，而且因为它有模块化和可自定义的架构，
在前后端分离的趋势下，用Django构建Web API也很容易。
缺：Django Models没有mixins，只有简单的继承。

优：支持单元测试，而且由于它的内置开发服务器、集成支持等等，
所以可以通过调整扩展来过渡到Web框架。比Django更加灵活
缺：有一个单独的来源源，表明它将依次处理每个请求，所以不管有多少个请求，
flask仍然轮流处理，这样花费的时间更多

优：基于Python3.6+标准类型提示，支持异步，就像它的名字一样，
FastAPI是为了快速API而生的，快速，高效。与NodeJS和Go可以相提并论。
基于JSON Schema的Fast API(用来验证JSON数据结构的工具)、OAuth2.0
(用来授权的行业标准协议)和OpenAPI(可公开获得的应用程序编程接口)等
标准之上的；自动类型检查意味着减少了bug，而且Fast API可以验证开发
人员的数据类型，即使是在深层嵌套JSON请求中也是如此。
缺：因为FastAPI比较新，所以相对于其他框架，社区比较小，第三方教程也比较少。

7.python的数据结构有哪些
字典 数组（列表，元祖，字符串） 集合 自定义数据结构（类）
栈（append，pop） 队列（collections.deque）

8.python切片
[开始:结束:步长] 越界不报错

9.元组和列表的异同
元祖：()，不可变
列表：[]，可变

10.手撕快排，并解释
# 按基准值，左大右小摆放，分而治之
def quick_sort(arr):
    if len(arr)>1: #递归入口
        mid = arr[0] #基值
        l, r = [], []
        arr.remove(mid)
        for i in arr:
            if i>mid:
                r.append(i) #大于基准值放右边
            else:
                l.append(i) #小于基准值放左边
        return quick_sort(l) + [mid] + quick_sort(r)
    else:
        return arr


Python垃圾回收机制，内存机制？
引用计数（sys.getrefcount()-1）为主，
标记清除(解决交叉引用)和分代回收(解决前者效率问题，gc.collect()可触发)为辅
内存管理机制为Pymalloc（内存池（如小整数池））
import psutil

arr = [1,0,3,1,52,3,0]

#本位与后面位比较，确定本位
def select_sort(arr):
    for i in range(len(arr)-1,0,-1):
        for j in range(i):
            if arr[i]<arr[j]:
                arr[i],arr[j]=arr[j],arr[i]
    return arr
# 两两比较，确定末位
def bubble_sort(arr):
    for i in range(len(arr)-1, 1, -1):
        flag = True
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1]=arr[j+1], arr[j]
                flag = False
        if flag:
            break
    return arr

# 按基准值，左大右小摆放，分而治之
def quick_sort(arr):
    if len(arr)>1: #递归入口
        mid = arr[0] #基值
        l, r = [], []
        arr.remove(mid)
        for i in arr:
            if i>mid:
                r.append(i) #大于基准值放右边
            else:
                l.append(i) #小于基准值放左边
        return quick_sort(l) + [mid] + quick_sort(r)
    else:
        return arr

#
def insertion_sort(arr):
    # 从数据第二个元素开始循环，直到最后一个元素
    for i in range(1, len(arr)):
        # 这个是我们想要放在正确位置的元素
        key_item = arr[i]
        # 初始化变量，用于寻找元素正确位置
        j = i - 1
        # 遍历元素左边的列表元素，一旦key_item比被比较元素小，那么找到正确位置插入。
        while j >= 0 and arr[j] > key_item:
            # 把被检测元素向左平移一个位置，并将j指向下一个元素（从右向左）
            arr[j + 1] = array[j]
            j -= 1
        # 当完成元素位置的变换，把key_item放在正确的位置上
        arr[j + 1] = key_item
    return arr
if __name__ == '__main__':
    # print(bubble_sort(arr))
    print(quick_sort(arr))

# 单例模型
#__new__()
class Singletion():
    def __new__(cls, *args, **kw):
        if not hasttr(cls, "_instance"): #查是否存在_intance
            cls._instance = super.__new__(cls)
        return cls._instance

class MyClass():
    _instance = None
    _isinit = False

    def __new__(cls, *args, **kwargs):
        if not _instance:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, x, y):
        cls = type(self)
        if not _isinit:
            self.x = x
            self.y = y
            cls.flag = True
